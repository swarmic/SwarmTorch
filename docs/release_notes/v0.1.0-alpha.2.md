# SwarmTorch v0.1.0-alpha.2 Release Notes

**Date:** 2025-12-15  
**Type:** Observability + Artifact Spine  

## Summary

This release implements the "artifact spine" — SwarmTorch's offline-first observability system. Run artifacts are self-contained bundles with path-addressed SHA-256 manifest hashing and NDJSON telemetry baselines.

---

## Major Features

### Run Artifact Bundle (`swarm-torch/src/artifacts.rs`)

**What:** A `RunArtifactBundle` type that manages on-disk run artifacts:

```
runs/<run_id>/
  manifest.json       # SHA-256 hashes of all files
  run.json            # Run metadata
  graph.json          # DAG of nodes/edges
  spans.ndjson        # Execution intervals
  events.ndjson       # Discrete facts
  metrics.ndjson      # Numeric measurements
  datasets/
    registry.json     # Dataset IDs, fingerprints, schemas
    lineage.json      # Input -> transform -> output edges
    materializations.ndjson
  artifacts/          # User artifacts (models, checkpoints)
```

**Why:**
1. **Offline-first:** Runs are fully self-contained; no tracking database required
2. **Integrity:** SHA-256 manifest enables verification without re-running
3. **Portability:** Copy the directory anywhere; all paths are relative
4. **OTel-compatible, OTel-independent:** Uses W3C ID sizes but doesn't require OTel crates

**How it works:**

```rust
// Create a new run bundle
let bundle = RunArtifactBundle::create("/data", run_id)?;

// Append telemetry during execution
bundle.append_span(&span_record)?;
bundle.append_event(&event_record)?;
bundle.append_metric(&metric_record)?;

// Finalize (computes manifest.json)
bundle.finalize_manifest()?;

// Later: validate integrity
bundle.validate_manifest()?;
```

**ADR Reference:** ADR-0016

### Canonical Observability IDs (`swarm-torch-core/src/observe.rs`)

**What:** Three ID types with OTel-compatible sizing:

| Type | Bytes | Hex Chars | Purpose |
|------|-------|-----------|---------|
| `TraceId` | 16 | 32 | Trace correlation across nodes |
| `SpanId` | 8 | 16 | Individual span identity |
| `RunId` | 16 | 32 | Run identity (default = root trace_id) |

**Design decisions:**

1. **All-zero is invalid:** Enforced at parse time to prevent sentinel confusion
2. **Human-readable JSON, compact binary:** Hex in JSON, raw bytes in binary formats
3. **Serde integration:** Custom Serialize/Deserialize for format-aware encoding

**Implementation detail:**

```rust
// The serializer adapts based on format
fn serialize_id_hex_or_bytes<S, const N: usize>(bytes: &[u8; N], ser: S) -> Result<S::Ok, S::Error> {
    if ser.is_human_readable() {
        // JSON: "0a1b2c3d..."
        ser.serialize_str(&hex_lower(bytes))
    } else {
        // Postcard/bincode: raw bytes
        ser.serialize_bytes(bytes)
    }
}
```

**ADR Reference:** ADR-0012, ADR-0016

### Telemetry Record Types

**What:** Three record types for NDJSON artifact files:

| Record | Purpose | Key Fields |
|--------|---------|------------|
| `SpanRecord` | Execution intervals | trace_id, span_id, parent_span_id, name, start/end_nanos, attrs |
| `EventRecord` | Discrete facts | ts_unix_nanos, trace_id, span_id, name, attrs |
| `MetricRecord` | Numeric measurements | ts_unix_nanos, name, value, unit, attrs |

**Why unified model:**
- One vocabulary for all telemetry
- Future visualization derives from these primitives
- No impedance mismatch between spans and metrics

**ADR Reference:** ADR-0016

---

## Architecture

### Manifest Hashing Strategy

**What:** SHA-256 over raw file bytes, path-addressed within bundle.

**Why SHA-256:**
- FIPS 180-4 standard, widely available
- 256-bit output is sufficient collision resistance
- Available in `sha2` crate (already in tree for crypto scaffolding)

**Why path-addressed:**
- Simple validation: hash(file) == manifest[path].sha256
- Relative paths enable bundle relocation
- `manifest.json` is non-self-referential (excludes itself)

**ADR Reference:** ADR-0016

### DataOps Baselines

**What:** Three files in `datasets/` directory:

| File | Purpose |
|------|---------|
| `registry.json` | Dataset IDs, fingerprints, schemas, license flags |
| `lineage.json` | Edges: inputs → transforms → outputs |
| `materializations.ndjson` | One row per stage output |

**Why:**
- Reproducibility: know exactly what data was used
- Compliance: audit trail for data provenance
- Debugging: understand data flow through pipeline

**Current status:** Schema placeholders; full implementation in ADR-0017.

**ADR Reference:** ADR-0016, ADR-0017

---

## Code Quality

### Test Coverage

**What:** `bundle_manifest_roundtrip` test validates:
1. Bundle creation succeeds
2. Span append succeeds
3. Manifest finalization computes SHA-256
4. Manifest validation passes

**Why:** Ensures the core artifact contract is maintained.

### Const Generic Workaround

**What:** Rust 1.75 doesn't support `N * 2` in array lengths for const generics.

**Workaround:** Use fixed-size buffer (32 bytes max) and slice:

```rust
// Rust 1.75 limitation: can't do `let mut buf = [0u8; N * 2]`
let mut buf = [0u8; 32];  // Max for 16-byte IDs
let hex_len = N * 2;
write_hex_lower(bytes, &mut buf[..hex_len]);
```

**ADR Reference:** N/A (Rust limitation)

---

## Security Considerations

### Privacy by Default

**What:** Artifacts MUST NOT contain raw dataset rows by default.

**Why:** Training data is often sensitive. Default to pointers + hashes.

**How:** `registry.json` stores fingerprints and URIs, not data.

**ADR Reference:** ADR-0016, SECURITY.md

---

## Known Limitations

1. **No Parquet yet:** NDJSON only; Parquet conversion pending
2. **No streaming finalize:** Manifest computed all-at-once
3. **No compression:** Large span files not compressed
4. **Graph schema placeholder:** `graph.json` nodes/edges are `serde_json::Value`

---

## Migration Notes

No breaking changes from v0.1.0-alpha.1. New module `artifacts.rs` is additive.

---

## Contributors

- Observability primitives: SwarmTorch team
- Artifact bundle implementation: SwarmTorch team
