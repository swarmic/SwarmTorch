# SwarmTorch v0.1.0-alpha.1 Release Notes

**Date:** 2025-11-12  
**Type:** Initial scaffold  

## Summary

This release establishes the foundational architecture for SwarmTorch, a Rust-native distributed machine learning framework. It includes the workspace structure, core primitives, and documentation framework.

---

## Architecture Decisions

### Multi-Crate Workspace Structure

**What:** SwarmTorch uses a Rust workspace with five crates:

| Crate | Purpose | `no_std` |
|-------|---------|----------|
| `swarm-torch-core` | Core traits, aggregation, compression, crypto | ✅ |
| `swarm-torch-net` | Transport abstraction, message envelope | ✅ |
| `swarm-torch-runtime` | Tokio/Embassy runtime abstraction | Partial |
| `swarm-torch-models` | Reference models, Burn integration | No |
| `swarm-torch` | User-facing re-exports, config | No |

**Why:** Separation of concerns enables:
- `no_std` core for embedded targets (ESP32, STM32)
- Feature-gated runtime selection (Tokio vs Embassy)
- Independent versioning of transport implementations

**ADR Reference:** ADR-0001, ADR-0002

### Feature Flag Philosophy

**What:** Features are strictly additive. Enabling a feature must not change behavior of code that doesn't use that feature.

**Why:** Prevents "spooky action at a distance" where downstream users are surprised by behavior changes when an unrelated feature is enabled.

**ADR Reference:** ADR-0002

---

## Core Primitives

### Robust Aggregation (`swarm-torch-core/src/aggregation.rs`)

**What:** Implemented aggregation strategies:

| Strategy | Byzantine Tolerance | Description |
|----------|---------------------|-------------|
| FedAvg | None | Simple weighted average |
| Median | (N-1)/2 byzantine | Coordinate-wise median |
| TrimmedMean | Configurable | Trim extreme values before averaging |
| Krum | (N-2f-2)/N byzantine | Multi-Krum selection |

**Why:**
- FedAvg is baseline (fast, no protection)
- Median is simple and well-understood
- TrimmedMean balances robustness with efficiency
- Krum is provably optimal for certain attack models

**How it works:**

```rust
// Trimmed mean: sort each coordinate, trim `trim_ratio` from each end
let n = gradients.len();
let trim = (n as f32 * trim_ratio) as usize;
for coord in 0..D {
    let mut vals: Vec<f32> = gradients.iter().map(|g| g[coord]).collect();
    vals.sort_by(|a, b| a.partial_cmp(b).unwrap());
    result[coord] = vals[trim..n-trim].iter().sum::<f32>() / (n - 2*trim) as f32;
}
```

**ADR Reference:** ADR-0007

### Compression Primitives (`swarm-torch-core/src/compression.rs`)

**What:** Three compression strategies for bandwidth-constrained networks:

| Mode | Factor | Description |
|------|--------|-------------|
| TopK | Variable | Keep only largest-magnitude coordinates |
| RandomSparse | Fixed | Random coordinate selection |
| Quantized | Fixed | Reduce precision to N bits |

**Why:** Mobile/embedded networks have limited bandwidth. A 1M parameter model at 32-bit precision = 4MB per update. With TopK(0.01) + 8-bit quantization, this drops to ~10KB.

**Trade-off:** Compression reduces communication but may slow convergence. The framework provides hooks for users to measure this trade-off.

**ADR Reference:** ADR-0007

### Identity and Roles (`swarm-torch-core/src/identity.rs`)

**What:** Four node roles with explicit capabilities:

| Role | Can Coordinate | Can Contribute | Can Observe |
|------|----------------|----------------|-------------|
| Coordinator | ✅ | Optional | ✅ |
| Contributor | ❌ | ✅ | ✅ |
| Observer | ❌ | ❌ | ✅ |
| Gateway | ✅ | Optional | ✅ |

**Why:** Heterogeneous fleets need explicit role boundaries. A resource-constrained sensor node should not accidentally become a coordinator.

**ADR Reference:** ADR-0008A

### Gradient Validation (`swarm-torch-core/src/crypto.rs`)

**What:** `GradientValidator` performs basic sanity checks:

- NaN/Inf detection
- Per-coordinate bounds check
- L2 norm bounds check

**Why:** Malicious or buggy nodes can send poison updates. These checks filter obvious attacks before aggregation.

**What it doesn't do:** Statistical anomaly detection, historical deviation analysis. These are future work.

**ADR Reference:** ADR-0008

---

## Transport Layer

### Message Envelope (`swarm-torch-net/src/protocol.rs`)

**What:** Single envelope format for all swarm messages:

```rust
pub struct SwarmEnvelope {
    pub protocol_version: (u8, u8),
    pub message_type: MessageType,
    pub sender: [u8; 16],       // PeerId
    pub sequence: u64,          // Monotonic, for replay protection
    pub timestamp: u64,         // Unix nanos, for expiry
    pub payload: Vec<u8>,       // Postcard-encoded inner message
    pub signature: Option<[u8; 64]>,  // Ed25519
}
```

**Why:**
- Uniform envelope simplifies parsing and validation
- Sequence + timestamp enable replay protection without complex state
- Optional signature allows gradual rollout of signing

**Current status:** Envelope fields exist; enforcement (replay cache, expiry rules) is not yet implemented.

**ADR Reference:** ADR-0004, ADR-0005

### Transport Trait (`swarm-torch-net/src/traits.rs`)

**What:** `SwarmTransport` trait with capability metadata:

```rust
pub trait SwarmTransport {
    type Error;
    async fn send(&mut self, peer: PeerId, msg: &[u8]) -> Result<(), Self::Error>;
    async fn recv(&mut self, buf: &mut [u8]) -> Result<(PeerId, usize), Self::Error>;
    fn capabilities(&self) -> TransportCapabilities;
}
```

**Why:** Transport-agnostic core enables:
- TCP for datacenter
- UDP for low-latency
- BLE for local mesh
- LoRa for long-range IoT

The `capabilities()` method informs the aggregation layer about reliability/bandwidth constraints.

**Current status:** `MockTransport` for testing; real transports are stubs.

**ADR Reference:** ADR-0004

---

## Observability

### Canonical IDs (`swarm-torch-core/src/observe.rs`)

**What:** Three ID types matching W3C/OTel sizing:

| Type | Size | Hex Length | Purpose |
|------|------|------------|---------|
| TraceId | 16 bytes | 32 chars | Trace correlation |
| SpanId | 8 bytes | 16 chars | Span identity |
| RunId | 16 bytes | 32 chars | Run identity (default = root trace_id) |

**Why:** OTel-compatible sizing enables future bridge to industry observability tools without being dependent on OTel crates (important for `no_std`).

**Design decision:** All-zero IDs are explicitly invalid (checked on parse and serialize).

**ADR Reference:** ADR-0012, ADR-0016

### Record Types

**What:** Three record types for NDJSON artifact files:

- `SpanRecord`: execution intervals
- `EventRecord`: discrete facts
- `MetricRecord`: numeric measurements

**Why:** Unified signal model simplifies artifact generation and future visualization.

**ADR Reference:** ADR-0016

---

## Runtime Abstraction

### `SwarmRuntime` Trait (`swarm-torch-runtime/src/lib.rs`)

**What:** Abstraction over async runtimes:

```rust
pub trait SwarmRuntime: Clone + Send + Sync + 'static {
    fn spawn<F>(&self, future: F)
    where
        F: Future<Output = ()> + Send + 'static;
}
```

**Why:** Different deployment targets need different runtimes:
- Desktop/server: Tokio
- Embedded: Embassy

The trait allows swarm code to be runtime-agnostic.

**Current status:** Tokio wrapper works; Embassy is placeholder.

**ADR Reference:** ADR-0002

---

## Documentation Framework

### Document Hierarchy

**What:** Clear hierarchy in `CONTEXT_SOURCES.md`:

| Level | Documents |
|-------|-----------|
| Primary | `SWARM_TORCH_TECHNICAL_WHITE_PAPER_v0.1.md`, `ADRs.md`, crate source |
| Secondary | `SWARMIC_NETWORK_WHITE_PAPER_v12.*.md` (integration context only) |

**Why:** Prevents context drift from cross-project documents. SwarmTorch is not SwarmicOS.

### ADR Consolidation

**What:** All ADRs are in a single `ADRs.md` file, not a `docs/adr/` directory.

**Why:** Simpler navigation, no broken links, easier to maintain.

---

## Security Posture

### Supply Chain

**What:** Three layers of dependency security:

| Tool | Purpose | Status |
|------|---------|--------|
| `cargo audit` | Known vulnerabilities | Config ready, CI pending |
| `cargo deny` | License/source policy | `deny.toml` configured |
| `cargo vet` | Human audit trail | `supply-chain/` stub |

**Why:** SwarmTorch targets mission-critical deployments. Unaudited transitive dependencies are a supply chain risk.

**ADR Reference:** ADR-0010 (implicit), SECURITY.md

### Current Crypto Status

**What:** Signing exists but is explicitly marked as **placeholder**.

**Why:** Real cryptographic implementation requires careful review. The current code demonstrates the interface but must not be used in production.

**ADR Reference:** ADR-0008

---

## Known Limitations

1. **No end-to-end swarm yet:** Crates compile; no working swarm loop.
2. **Transports are stubs:** Only `MockTransport` is functional.
3. **Embassy placeholder:** Embedded runtime not yet usable.
4. **Crypto placeholder:** Signing is not production-ready.
5. **`no_std` incomplete:** `--no-default-features` build fails; embedded example pending.

---

## Migration Notes

This is the initial release; no migration required.

---

## Contributors

- Initial scaffold and architecture: SwarmTorch team
